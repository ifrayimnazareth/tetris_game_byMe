<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Tetris Game</title>
  <style>
    /* Reset */
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: #121212;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #eee;
      user-select: none;
      height: 100vh;
      overflow: hidden;
    }
    h1 {
      margin: 10px 0 5px;
      font-weight: 700;
      color: #00bcd4;
      text-shadow: 0 0 10px #00bcd4aa;
    }
    p {
      margin: 10px 0 5px;
      font-weight: 700;
      font-family: Comic Sans MS, cursive;
      color: #00bcd4;
      text-shadow: 0 0 10px #00bcd4aa;
    }
    /* Container flex row for game + preview side by side */
    #game-preview-container {
      display: flex;
      gap: 20px;
      margin-top: 20px;
      align-items: flex-start;
      /* fixed width simulates scoreboard width below */
      width: 460px; 
    }
    #tetris {
      position: relative;
      width: 320px;
      height: 640px;
      background: #222;
      border: 3px solid #00bcd4;
      border-radius: 8px;
      box-shadow:
        inset 0 0 10px #00bcd4bb,
        0 0 20px #00bcd4cc;
    }
    canvas {
      display: block;
      background: #111;
      margin: 0 auto;
      outline: none;
      border: 1px solid #00bcd4;
      /* box-shadow: 0 0 10px #eee; */
    }
    #preview {
      box-shadow: 0 0 10px #eee;
    }
    #preview-container {
      /* smaller width to match canvas size */
      width: 120px;
      text-align: center;
      user-select: none;
    }
    #preview-label {
      color: #00bcd4;
      font-weight: 700;
      margin-bottom: 8px;
      font-size: 1.1rem;
      text-shadow: 0 0 8px #00bcd4cc;
    }
    #scoreboard {
      margin-top: 8px;
      width: 460px;
      display: flex;
      justify-content: space-between;
      font-size: 1.1rem;
      font-weight: 600;
      color: #00e5ff;
      text-shadow: 0 0 5px #00bcd4;
    }
    #message {
      margin-top: 10px;
      font-size: 1.2rem;
      color: #ff3b3b;
      font-weight: 700;
      min-height: 24px;
    }
    /* Pause overlay */
    #pause-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #pause-menu {
      text-align: center;
      background: #222;
      padding: 20px;
      border-radius: 8px;
      border: 3px solid #00bcd4;
      box-shadow: 0 0 20px #00bcd4cc;
    }
    #pause-menu h2 {
      color: #00bcd4;
      margin-bottom: 20px;
      font-size: 1.5rem;
      text-shadow: 0 0 10px #00bcd4aa;
    }
    .pause-btn {
      margin: 10px;
      padding: 18px 35px;
      font-size: 20px;
      background-color: #00bcd4;
      border: 3px solid #eee;
      box-shadow: 0 0 10px #eee;
      color: #eee;
      font-family: Comic Sans MS, cursive;
      border-radius: 11px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    .pause-btn:hover {
      background-color: #008ba3;
    }
    .pause-btn:active {
      background-color: #006974;
    }
    /* Responsive untuk layar kecil */
    @media (max-width: 480px) {
      .pause-btn {
        font-size: 18px;
        padding: 15px 30px;
      }
    }
    /* Controls for mobile */
    #controls {
      margin-top: 15px;
      width: 460px;
      display: flex;
      justify-content: space-between;
    }
    .btn {
      background: #00bcd4;
      border: none;
      border-radius: 6px;
      color: #111;
      font-weight: 700;
      font-size: 1.2rem;
      padding: 14px 18px;
      flex: 1;
      margin: 0 5px;
      box-shadow: 0 2px 4px #008ba3;
      user-select: none;
      touch-action: manipulation;
      transition: background-color 0.2s ease;
    }
    .btn:active {
      background: #008ba3;
      box-shadow: inset 0 2px 5px #006974;
    }
    #btn-pause {
      margin-top: 20px;
    }
    /* Responsive scaling and fit for smaller screens */
    @media (max-width: 480px) {
      #game-preview-container {
        width: 100%;
        flex-direction: column;
        align-items: center;
      }
      #tetris {
        width: 280px;
        height: 560px;
      }
      #preview-container {
        width: 120px;
        margin-top: 15px;
      }
      #scoreboard, #controls {
        width: 280px;
      }
      .btn {
        font-size: 1rem;
        padding: 12px 14px;
      }
    }
  </style>
</head>
<body>
  <h1>TETRIS</h1>
  <p>created by : alef</p>

  <div id="game-preview-container">
    <div id="tetris">
      <canvas id="game" width="320" height="640" tabindex="0" aria-label="Tetris game"></canvas>
    </div>
    <div id="preview-container" aria-label="Next piece preview">
      <div id="preview-label">Next</div>
      <canvas id="preview" width="120" height="120"></canvas>
      <button class="btn" id="btn-pause" aria-label="Pause Button">||</button>
    </div>
  </div>

  <div id="scoreboard">
    <div>Score: <span id="score">0</span></div>
    <div>Lines: <span id="lines">0</span></div>
    <div>Level: <span id="level">1</span></div>
  </div>
  <div id="message" role="alert" aria-live="polite"></div>
  <div id="controls" aria-label="Game controls for mobile">
    <button class="btn" id="btn-left" aria-label="Move left">⬅</button>
    <button class="btn" id="btn-rotate" aria-label="Rotate">⤾</button>
    <button class="btn" id="btn-right" aria-label="Move right">➡</button>
    <button class="btn" id="btn-drop" aria-label="Soft drop">⬇</button>
    <!-- <button class="btn" id="btn-pause" aria-label="Pause Button">||</button> -->
  </div>
  <!-- Pause Overlay -->
  <div id="pause-overlay">
    <div id="pause-menu">
      <h2>Game Paused</h2>
      <button class="pause-btn" id="resume-btn">Resume</button>
      <button class="pause-btn" id="reset-btn">Reset</button>
      <button class="pause-btn" id="exit-btn">Exit</button>
    </div>
  </div>
  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const previewCanvas = document.getElementById('preview');
    const previewCtx = previewCanvas.getContext('2d');
    const scoreElem = document.getElementById('score');
    const linesElem = document.getElementById('lines');
    const levelElem = document.getElementById('level');
    const messageElem = document.getElementById('message');
    const pauseOverlay = document.getElementById('pause-overlay');
    const resumeBtn = document.getElementById('resume-btn');
    const resetBtn = document.getElementById('reset-btn');
    const exitBtn = document.getElementById('exit-btn');
    const pauseBtn = document.getElementById('btn-pause');

    const ROWS = 20;
    const COLS = 10;
    const BLOCK_SIZE = 32;
    const PREVIEW_BLOCK_SIZE = 20; // smaller block size for preview

    const COLORS = [
      null,
      '#00ffff', // I - cyan
      '#0000ff', // J - blue
      '#ffa500', // L - orange
      '#ffff00', // O - yellow
      '#00ff00', // S - green
      '#800080', // T - purple
      '#ff0000'  // Z - red
    ];

    // Tetromino shapes: The 4x4 grid shapes
    const SHAPES = [
      [],
      [ // I
        [0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]
      ],
      [ // J
        [2,0,0],
        [2,2,2],
        [0,0,0]
      ],
      [ // L
        [0,0,3],
        [3,3,3],
        [0,0,0]
      ],
      [ // O
        [4,4],
        [4,4]
      ],
      [ // S
        [0,5,5],
        [5,5,0],
        [0,0,0]
      ],
      [ // T
        [0,6,0],
        [6,6,6],
        [0,0,0]
      ],
      [ // Z
        [7,7,0],
        [0,7,7],
        [0,0,0]
      ]
    ];

    class Piece {
      constructor(shapeId) {
        this.shape = SHAPES[shapeId];
        this.colorId = shapeId;
        this.x = Math.floor(COLS / 2) - Math.ceil(this.shape[0].length / 2);
        this.y = 0;
      }
      rotate() {
        const N = this.shape.length;
        const newShape = [];
        for (let x = 0; x < N; x++) {
          newShape[x] = [];
          for (let y = 0; y < N; y++) {
            newShape[x][y] = this.shape[N - y - 1][x] || 0;
          }
        }
        this.shape = newShape;
      }
    }

    const arena = createMatrix(COLS, ROWS);
    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let currentPiece = null;
    let nextPiece = null; // Variable to hold next piece
    let score = 0;
    let lines = 0;
    let level = 1;
    let gameOver = false;
    let isPause = false;

    function createMatrix(w, h) {
      const matrix = [];
      for (let i = 0; i < h; i++) {
        matrix.push(new Array(w).fill(0));
      }
      return matrix;
    }

    function drawBlock(ctx, x, y, size, colorId) {
      ctx.fillStyle = COLORS[colorId];
      ctx.strokeStyle = '#111';
      ctx.lineWidth = 2;
      ctx.fillRect(x * size, y * size, size, size);
      ctx.strokeRect(x * size, y * size, size, size);
    }

    function drawMatrix(ctx, matrix, offset, blockSize) {
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            drawBlock(ctx, x + offset.x, y + offset.y, blockSize, value);
          }
        });
      });
    }

    function draw() {
      // Clear main canvas
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawMatrix(ctx, arena, {x:0, y:0}, BLOCK_SIZE);
      drawMatrix(ctx, currentPiece.shape, {x: currentPiece.x, y: currentPiece.y}, BLOCK_SIZE);

      drawPreview();
    }

    function drawPreview() {
      // Clear preview canvas
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      previewCtx.fillStyle = '#111';
      previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
      if (!nextPiece) return;

      // Calculate offset to center piece in preview canvas
      const matrix = nextPiece.shape;
      const previewCanvasWidthBlocks = previewCanvas.width / PREVIEW_BLOCK_SIZE;
      const previewCanvasHeightBlocks = previewCanvas.height / PREVIEW_BLOCK_SIZE;

      const offsetX = Math.floor((previewCanvasWidthBlocks - matrix[0].length) / 2);
      const offsetY = Math.floor((previewCanvasHeightBlocks - matrix.length) / 2);

      drawMatrix(previewCtx, matrix, {x: offsetX, y: offsetY}, PREVIEW_BLOCK_SIZE);
    }

    function collide(matrix, piece) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x] !== 0 &&
            (arena[y + piece.y] &&
            arena[y + piece.y][x + piece.x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }

    function merge(arena, piece) {
      piece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            arena[y + piece.y][x + piece.x] = value;
          }
        });
      });
    }

    function arenaSweep() {
      let rowCount = 0;
      outer: for (let y = arena.length - 1; y >= 0; y--) {
        for (let x = 0; x < arena[y].length; x++) {
          if (arena[y][x] === 0) {
            continue outer;
          }
        }
        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
        y++; // check same row again

        rowCount++;
      }
      if (rowCount > 0) {
        let points = 0;
        switch(rowCount) {
          case 1: points = 40 * level; break;
          case 2: points = 100 * level; break;
          case 3: points = 300 * level; break;
          case 4: points = 1200 * level; break;
        }
        score += points;
        lines += rowCount;
        if (Math.floor(lines / 10) + 1 > level) {
          level++;
          dropInterval = Math.max(100, dropInterval - 100);
          showMessage("Level Up! Level "+level, 1500);
        }
      }
    }

    function resetPiece() {
      currentPiece = nextPiece || new Piece(Math.floor(Math.random() * (SHAPES.length - 1)) + 1);
      nextPiece = new Piece(Math.floor(Math.random() * (SHAPES.length - 1)) + 1);
      if (collide(arena, currentPiece)) {
        gameOver = true;
        showMessage("Game Over! Press R to Restart.");
      }
    }

    function drop() {
      currentPiece.y++;
      if (collide(arena, currentPiece)) {
        currentPiece.y--;
        merge(arena, currentPiece);
        arenaSweep();
        updateScore();
        resetPiece();
      }
      dropCounter = 0;
    }

    function move(dir) {
      currentPiece.x += dir;
      if (collide(arena, currentPiece)) {
        currentPiece.x -= dir;
      }
    }

    function rotatePiece() {
      const pos = currentPiece.x;
      let offset = 1;
      currentPiece.rotate();
      while (collide(arena, currentPiece)) {
        currentPiece.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > currentPiece.shape[0].length) {
          for (let i = 0; i < 3; i++) currentPiece.rotate();
          currentPiece.x = pos;
          return;
        }
      }
    }

    function updateScore() {
      scoreElem.textContent = score;
      linesElem.textContent = lines;
      levelElem.textContent = level;
    }

    function showMessage(text, duration=3000) {
      messageElem.textContent = text;
      if (duration > 0) {
        setTimeout(() => {
          if (!gameOver) messageElem.textContent = '';
        }, duration);
      }
    }

    function update(time = 0) {
      if (gameOver || isPause) return;
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) {
        drop();
      }
      draw();
      requestAnimationFrame(update);
    }

    document.addEventListener('keydown', event => {
      if(event.key == 'Escape') {
        if(!gameOver){
          isPause = !isPause;
          if(isPause) {
            messageElem.textContent = "Game Paused - Press ESC to Resume";
            pauseOverlay.style.display = 'flex';
          }
          else {
            messageElem.textContent = "";
            pauseOverlay.style.display = 'none';
            lastTime = performance.now();
            update();
          }
        }
      }
    });

    function restartGame() {
      for(let y=0; y<arena.length; y++) {
        arena[y].fill(0);
      }
      score = 0;
      lines = 0;
      level = 1;
      dropInterval = 1000;
      gameOver = false;
      messageElem.textContent = '';
      resetPiece();
      updateScore();
      lastTime = 0;
      dropCounter = 0;
      pauseOverlay.style.display = 'none';
      isPause = false;
      update();
    }

    document.addEventListener('keydown', event => {
      if (gameOver) {
        if (event.key.toLowerCase() === 'r') {
          restartGame();
        }
        return;
      }
      switch(event.key) {
        case 'ArrowLeft':
        case 'a':
          move(-1);
          break;
        case 'ArrowRight':
        case 'd':
          move(1);
          break;
        case 'ArrowDown':
        case 's':
          drop();
          break;
        case 'ArrowUp':
        case 'w':
        case 'x':
          rotatePiece();
          break;
        case 'r':
          restartGame();
          break;
        case ' ':
          while (!collide(arena, currentPiece)) {
            currentPiece.y++;
          }
          currentPiece.y--;
          merge(arena, currentPiece);
          arenaSweep();
          updateScore();
          resetPiece();
          dropCounter = 0;
          break;
      }
    });

    // Mobile buttons
    document.getElementById('btn-left').addEventListener('touchstart', e => {
      e.preventDefault();
      if (!gameOver) move(-1);
    });
    document.getElementById('btn-left').addEventListener('click', e => {
      e.preventDefault();
      if (!gameOver) move(-1);
    });
    document.getElementById('btn-right').addEventListener('touchstart', e => {
      e.preventDefault();
      if (!gameOver) move(1);
    });
    document.getElementById('btn-right').addEventListener('click', e => {
      e.preventDefault();
      if (!gameOver) move(1);
    });
    document.getElementById('btn-rotate').addEventListener('touchstart', e => {
      e.preventDefault();
      if (!gameOver) rotatePiece();
    });
    document.getElementById('btn-rotate').addEventListener('click', e => {
      e.preventDefault();
      if (!gameOver) rotatePiece();
    });
    document.getElementById('btn-drop').addEventListener('touchstart', e => {
      e.preventDefault();
      if (!gameOver) drop();
    });
    document.getElementById('btn-drop').addEventListener('click', e => {
      e.preventDefault();
      if (!gameOver) drop();
    });
  
    // Add buttons
    resumeBtn.addEventListener('click', () => {
      messageElem.textContent = "";
      pauseOverlay.style.display = 'none';
      lastTime = performance.now();
      isPause = false;
      update();
    });
    resumeBtn.addEventListener('touchstart', () => {
      messageElem.textContent = "";
      pauseOverlay.style.display = 'none';
      lastTime = performance.now();
      isPause = false;
      update();
    });
    resetBtn.addEventListener('click', () => {
      restartGame();
    });
    resetBtn.addEventListener('touchstart', () => {
      restartGame();
    });
    exitBtn.addEventListener('click', () => {
      window.location.href = 'index.html';
    });
    exitBtn.addEventListener('touchstart', () => {
      window.location.href = 'index.html';
    });
    pauseBtn.addEventListener('click', () => {
      isPause = !isPause;
      if (isPause) {
        messageElem.textContent = "Game Paused - Press ESC to Resume";
        pauseOverlay.style.display = 'flex';
      }
    });
    pauseBtn.addEventListener('touchstart', () => {
      isPause = !isPause;
      if (isPause) {
        messageElem.textContent = "Game Paused - Press ESC to Resume";
        pauseOverlay.style.display = 'flex';
      }
    });

    // Initialize
    resetPiece();
    updateScore();
    update();

    // Accessibility: Focus canvas for keyboard input on tap
    canvas.addEventListener('click', () => {
      canvas.focus();
    });
  })();
  </script>
</body>
</html>

